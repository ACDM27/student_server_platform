{
  "version": 3,
  "sources": ["../../../.pnpm/fractional-indexing@3.2.0/node_modules/fractional-indexing/src/index.js"],
  "sourcesContent": ["// License: CC0 (no rights reserved).\r\n\r\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\r\n\r\nexport const BASE_62_DIGITS =\r\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\r\n\r\n// `a` may be empty string, `b` is null or non-empty string.\r\n// `a < b` lexicographically if `b` is non-null.\r\n// no trailing zeros allowed.\r\n// digits is a string such as '0123456789' for base 10.  Digits must be in\r\n// ascending character code order!\r\n/**\r\n * @param {string} a\r\n * @param {string | null | undefined} b\r\n * @param {string} digits\r\n * @returns {string}\r\n */\r\nfunction midpoint(a, b, digits) {\r\n  const zero = digits[0];\r\n  if (b != null && a >= b) {\r\n    throw new Error(a + \" >= \" + b);\r\n  }\r\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\r\n    throw new Error(\"trailing zero\");\r\n  }\r\n  if (b) {\r\n    // remove longest common prefix.  pad `a` with 0s as we\r\n    // go.  note that we don't need to pad `b`, because it can't\r\n    // end before `a` while traversing the common prefix.\r\n    let n = 0;\r\n    while ((a[n] || zero) === b[n]) {\r\n      n++;\r\n    }\r\n    if (n > 0) {\r\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\r\n    }\r\n  }\r\n  // first digits (or lack of digit) are different\r\n  const digitA = a ? digits.indexOf(a[0]) : 0;\r\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\r\n  if (digitB - digitA > 1) {\r\n    const midDigit = Math.round(0.5 * (digitA + digitB));\r\n    return digits[midDigit];\r\n  } else {\r\n    // first digits are consecutive\r\n    if (b && b.length > 1) {\r\n      return b.slice(0, 1);\r\n    } else {\r\n      // `b` is null or has length 1 (a single digit).\r\n      // the first digit of `a` is the previous digit to `b`,\r\n      // or 9 if `b` is null.\r\n      // given, for example, midpoint('49', '5'), return\r\n      // '4' + midpoint('9', null), which will become\r\n      // '4' + '9' + midpoint('', null), which is '495'\r\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} int\r\n * @return {void}\r\n */\r\n\r\nfunction validateInteger(int) {\r\n  if (int.length !== getIntegerLength(int[0])) {\r\n    throw new Error(\"invalid integer part of order key: \" + int);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} head\r\n * @return {number}\r\n */\r\n\r\nfunction getIntegerLength(head) {\r\n  if (head >= \"a\" && head <= \"z\") {\r\n    return head.charCodeAt(0) - \"a\".charCodeAt(0) + 2;\r\n  } else if (head >= \"A\" && head <= \"Z\") {\r\n    return \"Z\".charCodeAt(0) - head.charCodeAt(0) + 2;\r\n  } else {\r\n    throw new Error(\"invalid order key head: \" + head);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} key\r\n * @return {string}\r\n */\r\n\r\nfunction getIntegerPart(key) {\r\n  const integerPartLength = getIntegerLength(key[0]);\r\n  if (integerPartLength > key.length) {\r\n    throw new Error(\"invalid order key: \" + key);\r\n  }\r\n  return key.slice(0, integerPartLength);\r\n}\r\n\r\n/**\r\n * @param {string} key\r\n * @param {string} digits\r\n * @return {void}\r\n */\r\n\r\nfunction validateOrderKey(key, digits) {\r\n  if (key === \"A\" + digits[0].repeat(26)) {\r\n    throw new Error(\"invalid order key: \" + key);\r\n  }\r\n  // getIntegerPart will throw if the first character is bad,\r\n  // or the key is too short.  we'd call it to check these things\r\n  // even if we didn't need the result\r\n  const i = getIntegerPart(key);\r\n  const f = key.slice(i.length);\r\n  if (f.slice(-1) === digits[0]) {\r\n    throw new Error(\"invalid order key: \" + key);\r\n  }\r\n}\r\n\r\n// note that this may return null, as there is a largest integer\r\n/**\r\n * @param {string} x\r\n * @param {string} digits\r\n * @return {string | null}\r\n */\r\nfunction incrementInteger(x, digits) {\r\n  validateInteger(x);\r\n  const [head, ...digs] = x.split(\"\");\r\n  let carry = true;\r\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\r\n    const d = digits.indexOf(digs[i]) + 1;\r\n    if (d === digits.length) {\r\n      digs[i] = digits[0];\r\n    } else {\r\n      digs[i] = digits[d];\r\n      carry = false;\r\n    }\r\n  }\r\n  if (carry) {\r\n    if (head === \"Z\") {\r\n      return \"a\" + digits[0];\r\n    }\r\n    if (head === \"z\") {\r\n      return null;\r\n    }\r\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\r\n    if (h > \"a\") {\r\n      digs.push(digits[0]);\r\n    } else {\r\n      digs.pop();\r\n    }\r\n    return h + digs.join(\"\");\r\n  } else {\r\n    return head + digs.join(\"\");\r\n  }\r\n}\r\n\r\n// note that this may return null, as there is a smallest integer\r\n/**\r\n * @param {string} x\r\n * @param {string} digits\r\n * @return {string | null}\r\n */\r\n\r\nfunction decrementInteger(x, digits) {\r\n  validateInteger(x);\r\n  const [head, ...digs] = x.split(\"\");\r\n  let borrow = true;\r\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\r\n    const d = digits.indexOf(digs[i]) - 1;\r\n    if (d === -1) {\r\n      digs[i] = digits.slice(-1);\r\n    } else {\r\n      digs[i] = digits[d];\r\n      borrow = false;\r\n    }\r\n  }\r\n  if (borrow) {\r\n    if (head === \"a\") {\r\n      return \"Z\" + digits.slice(-1);\r\n    }\r\n    if (head === \"A\") {\r\n      return null;\r\n    }\r\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\r\n    if (h < \"Z\") {\r\n      digs.push(digits.slice(-1));\r\n    } else {\r\n      digs.pop();\r\n    }\r\n    return h + digs.join(\"\");\r\n  } else {\r\n    return head + digs.join(\"\");\r\n  }\r\n}\r\n\r\n// `a` is an order key or null (START).\r\n// `b` is an order key or null (END).\r\n// `a < b` lexicographically if both are non-null.\r\n// digits is a string such as '0123456789' for base 10.  Digits must be in\r\n// ascending character code order!\r\n/**\r\n * @param {string | null | undefined} a\r\n * @param {string | null | undefined} b\r\n * @param {string=} digits\r\n * @return {string}\r\n */\r\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\r\n  if (a != null) {\r\n    validateOrderKey(a, digits);\r\n  }\r\n  if (b != null) {\r\n    validateOrderKey(b, digits);\r\n  }\r\n  if (a != null && b != null && a >= b) {\r\n    throw new Error(a + \" >= \" + b);\r\n  }\r\n  if (a == null) {\r\n    if (b == null) {\r\n      return \"a\" + digits[0];\r\n    }\r\n\r\n    const ib = getIntegerPart(b);\r\n    const fb = b.slice(ib.length);\r\n    if (ib === \"A\" + digits[0].repeat(26)) {\r\n      return ib + midpoint(\"\", fb, digits);\r\n    }\r\n    if (ib < b) {\r\n      return ib;\r\n    }\r\n    const res = decrementInteger(ib, digits);\r\n    if (res == null) {\r\n      throw new Error(\"cannot decrement any more\");\r\n    }\r\n    return res;\r\n  }\r\n\r\n  if (b == null) {\r\n    const ia = getIntegerPart(a);\r\n    const fa = a.slice(ia.length);\r\n    const i = incrementInteger(ia, digits);\r\n    return i == null ? ia + midpoint(fa, null, digits) : i;\r\n  }\r\n\r\n  const ia = getIntegerPart(a);\r\n  const fa = a.slice(ia.length);\r\n  const ib = getIntegerPart(b);\r\n  const fb = b.slice(ib.length);\r\n  if (ia === ib) {\r\n    return ia + midpoint(fa, fb, digits);\r\n  }\r\n  const i = incrementInteger(ia, digits);\r\n  if (i == null) {\r\n    throw new Error(\"cannot increment any more\");\r\n  }\r\n  if (i < b) {\r\n    return i;\r\n  }\r\n  return ia + midpoint(fa, null, digits);\r\n}\r\n\r\n/**\r\n * same preconditions as generateKeysBetween.\r\n * n >= 0.\r\n * Returns an array of n distinct keys in sorted order.\r\n * If a and b are both null, returns [a0, a1, ...]\r\n * If one or the other is null, returns consecutive \"integer\"\r\n * keys.  Otherwise, returns relatively short keys between\r\n * a and b.\r\n * @param {string | null | undefined} a\r\n * @param {string | null | undefined} b\r\n * @param {number} n\r\n * @param {string} digits\r\n * @return {string[]}\r\n */\r\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\r\n  if (n === 0) {\r\n    return [];\r\n  }\r\n  if (n === 1) {\r\n    return [generateKeyBetween(a, b, digits)];\r\n  }\r\n  if (b == null) {\r\n    let c = generateKeyBetween(a, b, digits);\r\n    const result = [c];\r\n    for (let i = 0; i < n - 1; i++) {\r\n      c = generateKeyBetween(c, b, digits);\r\n      result.push(c);\r\n    }\r\n    return result;\r\n  }\r\n  if (a == null) {\r\n    let c = generateKeyBetween(a, b, digits);\r\n    const result = [c];\r\n    for (let i = 0; i < n - 1; i++) {\r\n      c = generateKeyBetween(a, c, digits);\r\n      result.push(c);\r\n    }\r\n    result.reverse();\r\n    return result;\r\n  }\r\n  const mid = Math.floor(n / 2);\r\n  const c = generateKeyBetween(a, b, digits);\r\n  return [\r\n    ...generateNKeysBetween(a, c, mid, digits),\r\n    c,\r\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\r\n  ];\r\n}\r\n"],
  "mappings": "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",
  "names": ["ib", "fb", "ia", "fa", "i", "c"]
}
